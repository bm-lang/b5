# B5

B5 is an intermediate representation structure and language to create programs that can be compiled into executable code.

The intended use is to be autogenerated by using the API, despite the language can be autogenerated too, it was not conceived for production.

The syntax of B5 language is absurdly basic and definitely it is not optimized for human reading. The existence of the language is merely for testing and debugging purposes.

## Language Syntax

The language is composed by three types of elements:

- **Keywords**: Only letters in uppercase, helps to build the structure.
- **Literals**: Represent the custom names or values for the program, if the value starts with only letters followed by letters, digits or underscores, it can be written directly, otherwise it must be delimited with <code>`</code>.
- **Directives**: Special keywords that starts with `@`, it allows to perform actions on compiling time.

### Notation

In this document:
* The rules names are the title of the definitions.
* The **Keywords** are represented by the keyword itself.
* The **Literals** since they can be any value, are represented by the description of the literal delimited with <code>`</code>.
* Elements between `[]` can be omited.
* Elements between `{}` can be repeated.
* The character `>` represents a reference of another rule.

### Rules

#### Program

```
Program = { Type | Scalar | Proc |  Directive }
```

#### Type

Represents a structure of fields which can extend another type.

```
Type = "TYPE" Type-Name [ "EXTENDS" Another-Type ]
       [ "FIELDS" {+ Field-Name AS Field-Type / "," } ]
```

Literals:
* `Type-Name`: The global identifier for the type.
* `Another-Type`: The reference to other type which will be extended by inheriting its fields.
* `Field-Name`: The identifier of the field in the type.
* `Field-Type`: The reference to a type.

#### Scalar

Represents a globally accessible variable that is initialized once.

```
Scalar = "SCALAR" Scalar-Name "AS" Scalar-Type "INIT" Block
```

Literals:
* `Scalar-Name`
* `Scalar-Type`

#### Proc

Represents an invocable block of code that can receive parameters and return a value.

```
"PROC" Proc-Name [ "MAIN" ]
[ "PARAMS" {+ Param-Name "AS" Param-Type / "," } ]
[ "RETURNS" Return-Type ]
"BODY" Block
```

Literals:
* `Proc-Name`
* `Param-Name`
* `Param-Type`
* `Return-Type`

#### Instruction

```
Instruction = Block | Declare
```

##### Block

```
Block = "BEGIN" { Instruction } "END"
```

##### Declare a reference to a value

```
Declare = "DECLARE" Var-Name "AS" Var-Type "WITH" Expression
```

Literals:
* `Var-Name`
* `Var-Type`

##### Set a value to a reference

Sets to the reference the specified expression.

```
Set = "SET" Reference "VALUE" Expression
```

##### Conditional flow

```
IfElse = "IF" Expression "THEN" Instruction [ "ELSE" Instruction ]
```

##### Infinite loop

```
Loop = "LOOP" Instruction
```

##### Conditional loop

```
While = "WHILE" Expression "DO" Instruction
```

##### Defining a mark for jumping

```
Mark = "MARK" Mark-Name
```

Literals:
* `Mark-Name`

##### Jumping to a mark

```
Jump = "JUMP" Mark-Name
```

Literals:
* `Mark-Name`

##### Calling to a proc

```
Call = "CALL" Proc-Name [ "ARGS" {+ Expression / "," } ]
```

Literals:
* `Proc-Name`

##### Exiting returning a value

Exits the current procedure returning the specified value.

```
Return = "RETURN" Expression
```

##### Exiting without returning a value

Exits the current procedure without returning a value.

```
Exit = "EXIT"
```

##### Setting a value to an index of an array

```
Put = "PUT" Expression "INDEX" Expression "VALUE" Expression
```

##### Increments by one the reference

```
Inc = "INC" Reference
```

##### Decrements by one the reference

```
Dec = "DEC" Reference
```

#### Expressions

##### Null

```
Null = "NULL"
```

##### Referencing a value

Reference to a value.

```
Reference = "REF" { Ref-Name / "." }
```

##### Creating an empty instance of a type

Generates a reference to a new allocated structure of the specified type.

```
Object = "OBJECT" Type-Name
```

Literal:
* `Type-Name`

##### Creating an array

Generates a reference to a new allocated array of the specified size and type.

```
Array = "ARRAY" Expression
```

##### Creating an instance of a type from a literal

Generates a reference to the specified literal as type.

```
Literal = "LITERAL" Value "AS" Type
```

##### Checking if the given expression is of a type

Generates a `bool` indicating if the expression is compatible with the indicated type.

```
Is = "IS" Expression "OF" Type
```

##### Fetching a value from a proc invocation

Calls the indicated procedure with the arguments and returns the result.

```
Fetch = "FETCH" Proc-Name "ARGS" { Expression / "," }
```

##### Retrieving the length of an array

Returns an `uint32` representing the number of items that the array can hold.

```
Len = "LEN" Expression
```

##### Accessing to an item of an array by its index

Returns the value stored at the index location in the array.

```
"GET" Expression "INDEX" expression
```

##### Logical Operators

Generates `true` when the expression is `false`, and `false` when the expression is `true`.

```
"NOT" Expression
```

```
"AND" Expression "," Expression
```

```
"OR" Expression "," Expression
```

#### Arithmetic Operators

```
"ADD" Expression "," Expression
SUB
MUL
DIV
MOD
```

#### Relational Operators

Allow to compare two expressions of the same data type category.
All relational operators take 2 arguments and return a `bool` value.

| Syntax                          | Name                      |
| ------------------------------- | ------------------------- |
| `EQ right:expr WITH left:expr`  | Equal (=)                 |
| `NEQ right:expr WITH left:expr` | Not Equal (≠)             |
| `GT right:expr WITH left:expr`  | Greater than (>)          |
| `LT right:expr WITH left:expr`  | Less than (<)             |
| `GTE right:expr WITH left:expr` | Greater than or equal (≥) |
| `LTE right:expr WITH left:expr` | Less than or equal (≤)    |

Compatibility between data type categories.

| Data Type | Number | Boolean | Character
| --------- | ------ | ------- | ---------
| Number    | ✅ | ❌ | ❌ |
| Boolean   | ❌ | ✅ | ❌ |
| Character | ❌ | ❌ | ✅ |

#### Bitwise Operators

Allow to perform operations at bit level.
All bitwise operators take 2 arguments and return an _Integer_ value.

| Syntax                          | Name
| ------------------------------- | ----
| `BAN right:expr WITH left:expr` | Conjunction (∧)
| `BOR right:expr WITH left:expr` | Disjunction (∨)
| `XOR right:expr WITH left:expr` | Exclusive Disjunction (⊻)
| `NEG right:expr WITH left:expr` | Complement (¬)
| `SHL right:expr WITH left:expr` | Shift to the left
| `SHR right:expr WITH left:expr` | Shift to the right


### Data Types

| Name      | Size    | Categories                |
| --------- | ------- | ------------------------- |
| `int8`    | 8 bits  | Number, Integer, Signed   |
| `int16`   | 16 bits | Number, Integer, Signed   |
| `int32`   | 32 bits | Number, Integer, Signed   |
| `int64`   | 64 bits | Number, Integer, Signed   |
| `uint8`   | 8 bits  | Number, Integer, Unsigned |
| `uint16`  | 16 bits | Number, Integer, Unsigned |
| `uint32`  | 32 bits | Number, Integer, Unsigned |
| `uint64`  | 64 bits | Number, Integer, Unsigned |
| `float32` | 32 bits | Number, Float             |
| `float64` | 64 bits | Number, Float             |
| `bool`    | 8 bits  | Boolean                   |
| `char`    | 16 bits | Character                 |
| `array`   | ---     | Array                     |
